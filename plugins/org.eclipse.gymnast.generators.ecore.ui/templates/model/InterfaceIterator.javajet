<%@ jet package="translated" class="InterfaceIterator" %>

// (C) Copyright Darren Willis, David James Pearce and James Noble 2005. 
// Permission to copy, use, modify, sell and distribute this software 
// is granted provided this copyright notice appears in all copies. 
// This software is provided "as is" without express or implied 
// warranty, and with no claim as to its suitability for any purpose.
//
// Email: david.pearce@mcs.vuw.ac.nz

package jql.tracker;

import java.util.Iterator;

public class InterfaceIterator implements Iterator {
	InterfaceExtent target;
	InterfaceExtent current;
	Iterator<InterfaceExtent> subordinateIt;
	Iterator<Object> currentIt;
	public Object currentElement;
	public int repetitions=1;
	public int count=0;
	public String queryVar;
	public int column;
	public int size=0;
	
	public InterfaceIterator(){}
	
	public InterfaceIterator(InterfaceExtent caller){
		InterfaceExtent target = caller;
		subordinateIt = target.subordinateStores.iterator();
		if(subordinateIt.hasNext())
			current = (InterfaceExtent) subordinateIt.next();
		if(current != null)
			currentIt = current.iterator();
	}
	
	/*
	 * These iterators are meant to wrap around.
	 */
	public void backToStart(){
		currentElement = null;
		subordinateIt = target.subordinateStores.iterator();
		if(subordinateIt.hasNext())
			current = (InterfaceExtent) subordinateIt.next();
		else
			current = null;
		if(current != null)
			currentIt = current.iterator();
		else
			currentIt = null;
	}
	
	public boolean hasNext() {
		if(currentIt == null)
			return false;
		while(!(currentIt.hasNext())){
			if(subordinateIt.hasNext()){
				current = subordinateIt.next();
				currentIt = current.iterator();
			}else{
				break;
			}
		}
		return currentIt.hasNext();
	}

	/*
	 *  And they're generally used by stashing the 'next' object in the currentElement field
	 *  Since we will often need to reference an object many times before calling next
	 */
	public Object next() {
		while(!(currentIt.hasNext())){
			if(subordinateIt.hasNext()){
				current = subordinateIt.next();
				currentIt = current.iterator();
			}else{
				break;
			}
		}
		currentElement = currentIt.next();
		return currentElement;
	}

	public void remove() {}
	
}